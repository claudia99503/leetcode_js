/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    // 탐욕 지수 배열과 쿠키 크기 배열을 오름차순으로 정렬
    g.sort((a, b) => a - b);
    s.sort((a, b) => a - b);

    let i = 0; // 아이들의 인덱스
    let j = 0; // 쿠키들의 인덱스
    let contentChildren = 0;

    // 아이들과 쿠키들을 순회
    while (i < g.length && j < s.length) {
        if (s[j] >= g[i]) {
            // 현재 쿠키가 아이의 탐욕 지수보다 크거나 같으면
            contentChildren++;
            i++; // 다음 아이로 이동
        }
        j++; // 다음 쿠키로 이동
    }

    return contentChildren; // 만족한 아이들의 수 반환
};

/* 수도코드
1. **배열 정렬**:
    - `g` 배열(아이들의 탐욕 지수)을 오름차순으로 정렬합니다
    - `s` 배열(쿠키 크기)을 오름차순으로 정렬합니다

2. **변수 초기화**:
    - `i`를 0으로 설정 (아이들의 인덱스)
    - `j`를 0으로 설정 (쿠키들의 인덱스)
    - `contentChildren`을 0으로 설정 (만족한 아이들의 수를 세는 변수)

3. **아이들과 쿠키들을 순회**:
    - `i`가 `g` 배열의 길이보다 작고 `j`가 `s` 배열의 길이보다 작은 동안 반복합니다
        4. **현재 쿠키가 현재 아이를 만족시키는지 확인**:
            - 만약 `s[j]` (현재 쿠키의 크기)가 `g[i]` (현재 아이의 탐욕 지수)보다 크거나 같다면:
                - `contentChildren`을 1 증가시킵니다 (현재 아이가 만족합니다)
                - `i`를 1 증가시킵니다 (다음 아이로 이동)
        5. **다음 쿠키로 이동**:
            - `j`를 1 증가시킵니다 (다음 쿠키로 이동)

6. **결과 반환**:
    - `contentChildren`의 값을 반환합니다 (만족한 아이들의 수)

=> 핵심: 
오름차순으로 정렬해 놓으면, 작은 쿠키부터 차례로 비교하게 된다. 
그래서, 한 번 작은 쿠키가 어떤 아이를 만족시키지 못하면, 그 이후의 더 큰 욕심을 가진 아이들에게도 그 작은 쿠키는 맞지 않는다.
더하여, 이미 사용한 쿠키는 다시 사용할 수 없기 때문에 다시 처음부터 비교할 필요가 없다 !!
*/



